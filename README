Boiler-plate to make simple testing easier, when I do not want
a whole testing framework.

The basic idea is that you get this kind of interface:

  check_[TYPE](actual, expected);


The function returns 0 on success, and error code (typically 1) on failure.
for instance:

  error_code = check_int(val, 42);
  assert(error_code == 0);


To send error messages to a log, first construct a log object, which is
defined in echeck.h to be:
	struct echeck_log {
		void *context;
		void (*append_s)(struct echeck_log *log, const char *str);
		void (*append_ul)(struct echeck_log *log, unsigned long ul);
		void (*append_z)(struct echeck_log *log, size_t z);
		void (*append_l)(struct echeck_log *log, long l);
		void (*append_f)(struct echeck_log *log, double f);
		void (*append_vp)(struct echeck_log *log, const void *ptr);
		void (*append_eol)(struct echeck_log *log);
	}
Then use the "lcheck" form:

 error_code = lcheck_char(log, val, 'a');

In hosted systems which have stdio.h, to send error messages to a FILE*,
set the context on the default logger:

 FILE *logfile = fopen(filename, "w");
 echeck_default_log->context = logfile;
 error_code = check_char(val, 'a');


To include a message for additional context, use the "_m" form:

 error_code = check_size_t_m(size_of(foo), foo_len, "BAD MOJO!");


And the forms can be combined:

 error_code = lcheck_str_m(log, actual, "expected str", "BAD MOJO!")


To check a byte[] buffer, additional length parameters are required:

 error_code = check_byte_array(actual, actual_len, expected, expected_len);


To check a double, an epsilon is used to approximate equality.
For example, the would be equal:

 actual =  1.0000003;
 expect =  1.0000004;
 epsilon = 0.0001;
 error_code = check_double(actual, expected, epsilon);

The following would not be equal:

 actual =  1.0000003;
 expect =  1.0000004;
 epsilon = 0.000000001;
 error_code = check_double(actual, expected, epsilon);

For ease of use, a default scaled epsilon is available:

 check_double_scaled_epsilon(actual, expected);

is the same as, and #defined to be:

 check_double(actual, expected, ((expected) * DBL_EPSILON));

Thus, if "expected" is a function with side-effects, that the call to
"check_double_scaled_epsilon" will call the "expected" function twice.


If you wish to return from main() with a count of errors, this can be
error-prone, especially if (failures % 256 == 0). This will not be a problem
if you use "check_status", because this function caps values at 127 (and -128).

 return check_status(failures);



Packaging
---------
autoreconf -iv &&
 ./configure &&
 make &&
 make distcheck &&
 echo "Success."


License
-------
GNU Lesser General Public License (LGPL), version 3 or later.
See COPYING, COPYING.LESSER for details.
