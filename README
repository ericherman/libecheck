Boiler-plate to make simple testing easier, when I do not want
a whole testing framework.

The basic idea is that you get this kind of interface:

  check_[TYPE](actual, expected);


The function returns 0 on success, and error code (typically 1) on failure.
for instance:

  error_code = check_int(val, 42);
  assert(error_code == 0);


To send error messages to a FILE, use the "fcheck" form:

 error_code = fcheck_char(log, val, 'a');


To include a message for additional context, use the "_m" form:

 error_code = check_size_t_m(size_of(foo), foo_len, "BAD MOJO!");


And the forms can be combined:

 error_code = fcheck_str_m(log, actual, "expected str", "BAD MOJO!")


To check a byte[] buffer, additional length parameters are required:

 error_code = check_byte_array(actual, actual_len, expected, expected_len);


To check a double, an epsilon is used to approximate equality.
For example, the would be equal:

 actual =  1.0000003;
 expect =  1.0000004;
 epsilon = 0.0001;
 error_code = check_double(actual, expected, epsilon);

The following would not be equal:

 actual =  1.0000003;
 expect =  1.0000004;
 epsilon = 0.000000001;
 error_code = check_double(actual, expected, epsilon);

For ease of use, a default scaled epsilon is available:

 check_double_scaled_epsilon(actual, expected);

is the same as, and #defined to be:

 check_double(actual, expected, ((expected) * DBL_EPSILON));

Thus, if "expected" is a function with side-effects, that the call to
"check_double_scaled_epsilon" will call the "expected" function twice.


If you wish to return from main() with a count of errors, this can be
error-prone, especially if (failures % 256 == 0). This will not be a problem
if you use "check_status", because this function caps values at 127 (and -128).

 return check_status(failures);



Packaging
---------
autoreconf -iv &&
 ./configure &&
 make &&
 make distcheck &&
 echo "Success."


License
-------
GNU Lesser General Public License (LGPL), version 3 or later.
See COPYING, COPYING.GPL3 for details.
